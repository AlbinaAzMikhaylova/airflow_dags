from airflow.models.operator import BaseOperator

# Создаем класс кастомного оператора
class TestOperator(BaseOperator):
    template_fields = ('type_of_table',) # Этот параметр указывает, что параметр type_of_table является шаблонным параметром. Шаблонные параметры используются для передачи параметров в операторы.

    def __init__(self, type_of_table, *args, **kwargs): # Конструктор класса. type_of_table - параметр, который передается в оператор/ (наш кастомный оператор)
        super().__init__(*args, **kwargs) # super() - это метод, который вызывает метод родительского класса. Т е мы вызываем __init__ родительского класса (BaseOperator). Без super().__init__() ваш оператор не будет корректно инициализирован, и Airflow не сможет понять, как с ним работать (например, он не будет знать, к какому DAG он относится). Это как сказать: "Сначала сделай всё, что нужно родительскому классу, а потом добавь мои настройки".


        self.type_of_table = type_of_table # Инициализируем параметр type_of_table. Так как он кастомный, и base operator не знает, что делать с ним, то мы его инициализируем.

    def test_func(self): # Более редкий случай, когда мы хотим использовать кастомный метод в операторе.
        pass

    def execute(self, context): # Метод execute. Этот метод вызывается при выполнении оператора. Он так же обязательный метод класса, так как он будет вызываться при выполнении оператора. context - это контекст выполнения оператора, он передается в метод execute, а не INIT!
        self.test_func() # Вызываем метод test_func

        self.log.info(context['ds']) # Например, наш метод будет выводить дату выполнения оператора.

# Создаем task
test_op = TestOperator(
    task_id = 'test_operator', # Имя task
    type_of_table = '{{ ds }}' # Параметр, который передается в оператор
)

# Вся конструкция, кроме def test_func, является обязательной для любого оператора. Она выполняет 95% всех задач. Соответсвенно метод execute разрастается под задачу.

